{"version":3,"file":"index.mjs","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/misc/logger.ts","../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/file-parser.ts","../src/misc/pathHelper.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/database/ResourceManager.ts","../src/misc/timestamp-parser.ts","../src/providers/database/FireClient.ts","../src/misc/metadata-parser.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetManyReference.ts","../src/providers/queries/GetMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/DataProvider.ts","../src/misc/status-code-translator.ts","../src/providers/AuthProvider.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { RAFirebaseOptions } from \"../providers/RAFirebaseOptions\";\n\n// UTILS\n\nexport class SimpleLogger {\n  private title = \"ðŸ”¥r-a-f: \";\n\n  isEnabled() {\n    return !!localStorage.getItem(\"LOGGING_ENABLED\");\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return (...args: any) => {};\n    }\n    const boundLogFn: (...args: any) => void = console.log.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return (...args: any) => {};\n    }\n    const boundLogFn: (...args: any) => void = console.warn.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return (...args: any) => {};\n    }\n    const boundLogFn: (...args: any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n\nconst logger = new SimpleLogger();\n\nexport function CheckLogging(\n  config: {} & { debug?: boolean },\n  options: RAFirebaseOptions\n) {\n  const logSignalDeprecated = config && config.debug;\n  const logSignal = options && options.logging;\n  if (logSignalDeprecated || logSignal) {\n    localStorage.setItem(\"LOGGING_ENABLED\", \"true\");\n  } else {\n    localStorage.removeItem(\"LOGGING_ENABLED\");\n  }\n}\n\nexport const log = logger.log;\nexport const logWarn = logger.warn;\nexport const logError = logger.error;\n","import { isEmpty, get } from \"lodash\";\nimport { SearchObj, getFieldReferences } from \"./objectFlatten\";\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: \"asc\" | \"desc\"\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = get(a, field);\n    const rawB = get(b, field);\n    const isAsc = dir === \"asc\";\n\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    if (isNumberField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    const isStringField = typeof rawA == \"string\" && typeof rawB == \"string\";\n    if (isStringField) {\n      const aParsed = rawA.toLowerCase();\n      const bParsed = rawB.toLowerCase();\n      return basicSort(aParsed, bParsed, isAsc);\n    }\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\n    if (isDateField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    return basicSort(!!rawA, !!rawB, isAsc);\n  });\n}\n\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\n  if (aValue > bValue) {\n    return isAsc ? 1 : -1;\n  }\n  if (aValue < bValue) {\n    return isAsc ? -1 : 1;\n  }\n  return 0;\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields?: { [field: string]: string | number | boolean | null }\n): Array<{}> {\n  if (!searchFields || isEmpty(searchFields)) {\n    return data;\n  }\n  const searchObjs: SearchObj[] = [];\n  Object.keys(searchFields).map((fieldName) => {\n    const fieldValue = searchFields[fieldName];\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\n    searchObjs.push(...getSubObjects);\n  });\n  const filtered = data.filter((row) =>\n    searchObjs.reduce((acc, cur) => {\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\n      return res && acc;\n    }, true as boolean)\n  );\n  return filtered;\n}\n\nexport function doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: any\n): boolean {\n  const searchThis = get(row, searchField);\n  const bothAreFalsey = !searchThis && !searchValue;\n  if (bothAreFalsey) {\n    return true;\n  }\n  const nothingToSearch = !searchThis;\n  if (nothingToSearch) {\n    return false;\n  }\n  const isStringSearch = typeof searchValue === \"string\";\n  if (isStringSearch) {\n    return searchThis\n      .toString()\n      .toLowerCase()\n      .includes(searchValue.toLowerCase());\n  }\n  const isBooleanOrNumber =\n    typeof searchValue === \"boolean\" || typeof searchValue === \"number\";\n  if (isBooleanOrNumber) {\n    return searchThis === searchValue;\n  }\n  return false;\n}\n","export interface SearchObj {\n  searchField: string;\n  searchValue: number | string | boolean | null;\n}\nexport function getFieldReferences(\n  fieldName: string,\n  value: {} | number | string | boolean | null\n): SearchObj[] {\n  const isFalsey = !value;\n  const isSimple = isFalsey;\n  typeof value === \"string\" ||\n    typeof value === \"number\" ||\n    typeof value === \"boolean\";\n  if (isSimple) {\n    return [\n      {\n        searchField: fieldName,\n        searchValue: value as number | string | boolean | null,\n      },\n    ];\n  }\n  const tree = {} as any;\n  tree[fieldName] = value;\n  return objectFlatten(tree);\n}\n\nexport function objectFlatten(tree: {}): SearchObj[] {\n  var leaves: SearchObj[] = [];\n  var recursivelyWalk = function (obj: any, path: string | null) {\n    path = path || \"\";\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const objVal = obj && obj[key];\n        const currentPath = !!path ? path + \".\" + key : key;\n        const isWalkable =\n          typeof objVal === \"object\" || objVal instanceof Array;\n        if (isWalkable) {\n          recursivelyWalk(objVal, currentPath);\n        } else {\n          leaves.push({ searchField: currentPath, searchValue: objVal });\n        }\n      }\n    }\n  };\n  recursivelyWalk(tree, null);\n  return leaves;\n}\n","import { logError } from \"./logger\";\nimport { IFirebaseWrapper } from \"../providers/database/firebase/IFirebaseWrapper\";\n\ninterface ParsedUpload {\n  fieldDotsPath: string;\n  fieldSlashesPath: string;\n  rawFile: File | any;\n}\n\nexport function parseDocGetAllUploads(obj: any): ParsedUpload[] {\n  const isObject = !!obj && typeof obj === \"object\";\n  if (!isObject) {\n    return [];\n  }\n  const uploads: ParsedUpload[] = [];\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    recusivelyParseObjectValue(value, key, uploads);\n  });\n  return uploads;\n}\n\nexport function recusivelyParseObjectValue(\n  input: any,\n  fieldPath: string,\n  uploads: ParsedUpload[]\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== \"object\";\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === \"function\";\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map((value, index) =>\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, uploads)\n    );\n  }\n  const isObject = typeof input === \"object\";\n  if (!isObject) {\n    return;\n  }\n  const isFileField = !!input && input.hasOwnProperty(\"rawFile\");\n  if (isFileField) {\n    uploads.push({\n      fieldDotsPath: fieldPath,\n      fieldSlashesPath: fieldPath.split('.').join('/'),\n      rawFile: input.rawFile,\n    });\n    delete input.rawFile;\n    return;\n  }\n  Object.keys(input).map((key) => {\n    const value = input[key];\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, uploads);\n  });\n  return input;\n}\n\nexport const recursivelyMapStorageUrls = async (\n  fireWrapper: IFirebaseWrapper,\n  fieldValue: any\n): Promise<any> => {\n  const isArray = Array.isArray(fieldValue);\n  const isObject = !isArray && typeof fieldValue === \"object\";\n  const isFileField = isObject && !!fieldValue && fieldValue.hasOwnProperty(\"src\");\n  if (isFileField) {\n    try {\n      const src = await fireWrapper.storage().ref(fieldValue.src).getDownloadURL();\n      return {\n        ...fieldValue,\n        src\n      };\n    } catch (error) {\n      logError(`Error when getting download URL`, {\n        error\n      });\n      return fieldValue;\n    }\n  } else if (isObject) {\n    for (let key in fieldValue) {\n      if (fieldValue.hasOwnProperty(key)) {\n        const value = fieldValue[key];\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\n      }\n    }\n\n    return fieldValue;\n  } else if (isArray) {\n    for (let i = 0; i < fieldValue.length; i++) {\n      fieldValue[i] = await recursivelyMapStorageUrls(fireWrapper, fieldValue[i])\n    }\n\n    return fieldValue;\n  }\n\n  return fieldValue;\n};\n","import path from \"path-browserify\";\n\nexport function getAbsolutePath(\n  rootRef: undefined | string | (() => string),\n  relativePath: string | null\n): string {\n  if (!rootRef) {\n    return relativePath+'';\n  }\n  if (!relativePath) {\n    throw new Error(\n      \"Resource name must be a string of length greater than 0 characters\"\n    );\n  }\n  const rootRefValue = typeof rootRef === \"string\" ? rootRef : rootRef();\n  const withSlashes = path.join(\"/\", rootRefValue, \"/\", relativePath, \"/\");\n  const slashCount = withSlashes.split(\"/\").length - 1;\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\" not a \"collection\"\ne.g. /collection/document/ or /collection/document/collection/document/`);\n  }\n  const withOutSlashes = withSlashes.slice(1, -1);\n  return withOutSlashes;\n}\n\nexport function joinPaths(...args: string[]) {\n  return path.join(...args);\n}\n","import { FireApp, IFirebaseWrapper } from \"./IFirebaseWrapper\";\nimport { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\n\nimport firebase, { User } from \"firebase/app\";\nimport \"firebase/firestore\";\nimport \"firebase/auth\";\nimport \"firebase/storage\";\nimport { log } from \"misc\";\n\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private firestore: firebase.firestore.Firestore = null as any;\n  private app: FireApp = null as any;\n  public options: RAFirebaseOptions = {};\n\n  public GetApp(): FireApp {\n    return this.app;\n  }\n\n  constructor() { }\n\n  public init(firebaseConfig: {}, options?: RAFirebaseOptions): void {\n    const optionsSafe = options || {};\n    this.options = optionsSafe;\n    this.app = ObtainFirebaseApp(firebaseConfig, optionsSafe);\n    this.firestore = this.app.firestore();\n  }\n  public db(): firebase.firestore.Firestore {\n    return this.firestore;\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    // return firebase.firestore.FieldValue.serverTimestamp();\n    return new Date();\n  }\n  public auth() {\n    return this.app.auth() as any;\n  }\n  public storage() {\n    return this.app.storage();\n  }\n  public async GetUserLogin(): Promise<User> {\n    return new Promise((resolve, reject) => {\n      this.app.auth().onAuthStateChanged((user) => {\n        if (user) {\n          resolve(user);\n        } else {\n          reject(\"getUserLogin() no user logged in\");\n        }\n      });\n    });\n  }\n  public OnUserLogout(callBack: (u: firebase.User | null) => any) {\n    this.app.auth().onAuthStateChanged(user => {\n      const isLoggedOut = !user;\n      log('FirebaseWrapper.OnUserLogout', {user, isLoggedOut});\n      if (isLoggedOut) {\n        callBack(user);\n      }\n    });\n  }\n}\n\nfunction ObtainFirebaseApp(firebaseConfig: {}, options: RAFirebaseOptions): firebase.app.App {\n  if (options.app) {\n    return options.app;\n  }\n  const isInitialized = !!firebase.apps.length;\n  if (isInitialized) {\n    const app = firebase.app();\n    return app;\n  } else {\n    const app = firebase.initializeApp(firebaseConfig);\n    return app;\n  }\n}","// Firebase types\nimport {\n  CollectionReference,\n  QueryDocumentSnapshot,\n  FirebaseFirestore,\n} from \"@firebase/firestore-types\";\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { User } from \"@firebase/auth-types\";\nimport {\n  log,\n  getAbsolutePath,\n  messageTypes,\n  logError,\n  parseAllDatesDoc,\n  logWarn,\n} from \"../../misc\";\n\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: CollectionReference;\n  list: Array<{} & { deleted?: boolean }>;\n}\n\nexport class ResourceManager {\n  private resources: {\n    [resourceName: string]: IResource;\n  } = {};\n\n  private db: FirebaseFirestore;\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions\n  ) {\n    this.db = fireWrapper.db();\n\n    this.fireWrapper.OnUserLogout((user) => {\n      this.resources = {};\n    });\n  }\n\n  public async TryGetResource(\n    resourceName: string,\n    refresh?: \"REFRESH\",\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log(\"resourceManager.TryGetResourcePromise\", {\n      relativePath,\n      collectionQuery,\n    });\n    await this.initPath(relativePath, collectionQuery);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType | undefined\n  ) {\n    log(\"resourceManager.RefreshResource\", { relativePath, collectionQuery });\n    await this.initPath(relativePath, collectionQuery);\n    const resource = this.resources[relativePath];\n\n    const collection = resource.collection;\n    const query = this.applyQuery(collection, collectionQuery);\n    const newDocs = await query.get();\n\n    resource.list = newDocs.docs.map((doc) => this.parseFireStoreDocument(doc));\n    log(\"resourceManager.RefreshResource\", {\n      newDocs,\n      resource,\n      collectionPath: collection.path,\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n    const docSnap = await resource.collection.doc(docId).get();\n    if (!docSnap.exists) {\n      throw new Error(\"react-admin-firebase: No id found matching: \" + docId);\n    }\n    const result = this.parseFireStoreDocument(docSnap as any);\n    log(\"resourceManager.GetSingleDoc\", {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result,\n    });\n    return result;\n  }\n\n  private async initPath(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<void> {\n    const rootRef = this.options && this.options.rootRef;\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\n    const hasBeenInited = !!this.resources[relativePath];\n    log(\"resourceManager.initPath()\", {\n      absolutePath,\n      hasBeenInited,\n    });\n    if (hasBeenInited) {\n      log(\"resourceManager.initPath() has been initialized already...\");\n      return;\n    }\n    const collection = this.db.collection(absolutePath);\n    const list: Array<{}> = [];\n    const resource: IResource = {\n      collection: collection,\n      list: list,\n      path: relativePath,\n      pathAbsolute: absolutePath,\n    };\n    this.resources[relativePath] = resource;\n    log(\"resourceManager.initPath() setting resource...\", {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path,\n    });\n  }\n\n  private parseFireStoreDocument(doc: QueryDocumentSnapshot | undefined): {} {\n    if (!doc) {\n      logWarn(\"parseFireStoreDocument: no doc\", { doc });\n      return {};\n    }\n    const data = doc.data();\n    parseAllDatesDoc(data);\n    // React Admin requires an id field on every document,\n    // So we can just using the firestore document id\n    return { id: doc.id, ...data };\n  }\n\n  public async getUserIdentifier(): Promise<string> {\n    const identifier = this.options.associateUsersById\n      ? await this.getCurrentUserId()\n      : await this.getCurrentUserEmail();\n    return identifier;\n  }\n\n  private async getCurrentUserEmail() {\n    const user = await this.fireWrapper.GetUserLogin();\n    if (user) {\n      return user.email as string;\n    } else {\n      return \"annonymous user\";\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.fireWrapper.GetUserLogin();\n    if (user) {\n      return user.uid;\n    } else {\n      return \"annonymous user\";\n    }\n  }\n\n  private removeResource(resourceName: string) {\n    delete this.resources[resourceName];\n  }\n\n  private applyQuery(\n    collection: CollectionReference,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): CollectionReference {\n    let collref: CollectionReference;\n    if (collectionQuery) {\n      collref = collectionQuery(collection);\n    } else {\n      collref = collection;\n    }\n    log(\"resourceManager.applyQuery() ...\", {\n      collection,\n      collectionQuery: (collectionQuery || \"-\").toString(),\n      collref,\n    });\n    return collref;\n  }\n}\n","export function parseAllDatesDoc(obj: any) {\n  const isObject = !!obj && typeof obj === 'object';\n  if (!isObject) {\n    return;\n  }\n  Object.keys(obj).map(key => {\n    const value = obj[key];\n    obj[key] = recusivelyCheckObjectValue(value);\n  });\n}\n\nexport function recusivelyCheckObjectValue(input: any): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map(value => recusivelyCheckObjectValue(value));\n  }\n  const isObject = typeof input === 'object';\n  if (isObject) {\n    Object.keys(input).map(key => {\n      const value = input[key];\n      input[key] = recusivelyCheckObjectValue(value);\n    });\n    return input;\n  }\n}","import { set } from \"lodash\";\nimport {\n  AddCreatedByFields,\n  AddUpdatedByFields,\n  joinPaths,\n  log,\n  logError,\n  parseDocGetAllUploads,\n} from \"../../misc\";\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { IResource, ResourceManager } from \"./ResourceManager\";\n\nexport class FireClient {\n  public rm: ResourceManager;\n  public db() {\n    return this.fireWrapper.db();\n  }\n\n  constructor(\n    public fireWrapper: IFirebaseWrapper,\n    public options: RAFirebaseOptions\n  ) {\n    this.rm = new ResourceManager(this.fireWrapper, this.options);\n  }\n\n  public checkRemoveIdField(obj: any) {\n    if (this.options.dontAddIdFieldToDoc) {\n      delete obj.id;\n    }\n  }\n\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = r.collection.doc(id).path;\n\n    const uploads = parseDocGetAllUploads(data);\n    await Promise.all(\n      uploads.map(async (u) => {\n        const link = await this.uploadAndGetLink(\n          u.rawFile,\n          docPath,\n          u.fieldSlashesPath,\n          !!this.options.useFileNamesInStorage\n        );\n        set(data, u.fieldDotsPath + \".src\", link);\n      })\n    );\n    return data;\n  }\n\n  public async addCreatedByFields(obj: any) {\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  public async addUpdatedByFields(obj: any) {\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  private async uploadAndGetLink(\n    rawFile: any,\n    docPath: string,\n    fieldPath: string,\n    useFileName: boolean\n  ): Promise<string | undefined> {\n    const storagePath = useFileName\n      ? joinPaths(docPath, fieldPath, rawFile.name)\n      : joinPaths(docPath, fieldPath);\n    return this.saveFile(storagePath, rawFile);\n  }\n\n  private async saveFile(\n    storagePath: string,\n    rawFile: any\n  ): Promise<string | undefined> {\n    log(\"saveFile() saving file...\", { storagePath, rawFile });\n    const task = this.fireWrapper.storage().ref(storagePath).put(rawFile);\n    try {\n      const taskResult: firebase.storage.UploadTaskSnapshot = await new Promise(\n        (res, rej) => task.then(res).catch(rej)\n      );\n      const getDownloadURL = await taskResult.ref.getDownloadURL();\n      log(\"saveFile() saved file\", {\n        storagePath,\n        taskResult,\n        getDownloadURL,\n      });\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\n    } catch (storageError) {\n      if (storageError.code === \"storage/unknown\") {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError(\"saveFile() error saving file\", {\n          storageError,\n        });\n      }\n    }\n  }\n}\n","import { RAFirebaseOptions } from \"index\";\nimport { IFirebaseWrapper, ResourceManager } from \"providers/database\";\n\nexport async function AddCreatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\n  options: Pick<\n    RAFirebaseOptions,\n    | \"associateUsersById\"\n    | \"disableMeta\"\n    | \"renameMetaFields\"\n    | \"metaFieldCasing\"\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const createAtSelector = GetSelectorsCreateAt(options);\n  const createBySelector = GetSelectorsCreateBy(options);\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\n  obj[createBySelector] = currentUserIdentifier;\n}\n\nexport async function AddUpdatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\n  options: Pick<\n    RAFirebaseOptions,\n    | \"associateUsersById\"\n    | \"disableMeta\"\n    | \"renameMetaFields\"\n    | \"metaFieldCasing\"\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const updateAtSelector = GetSelectorsUpdateAt(options);\n  const updateBySelector = GetSelectorsUpdateBy(options);\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\n  obj[updateBySelector] = currentUserIdentifier;\n}\n\nexport function GetSelectorsUpdateAt(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\n    return options.renameMetaFields.updated_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"lastupdate\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"lastUpdate\";\n  }\n  if (casing === \"snake\") {\n    return \"last_update\";\n  }\n  if (casing === \"pascal\") {\n    return \"LastUpdate\";\n  }\n  if (casing === \"kebab\") {\n    return \"last-update\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsUpdateBy(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\n    return options.renameMetaFields.updated_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"updatedby\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"updatedBy\";\n  }\n  if (casing === \"snake\") {\n    return \"updated_by\";\n  }\n  if (casing === \"pascal\") {\n    return \"UpdatedBy\";\n  }\n  if (casing === \"kebab\") {\n    return \"updated-by\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateAt(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\n    return options.renameMetaFields.created_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"createdate\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"createDate\";\n  }\n  if (casing === \"snake\") {\n    return \"create_date\";\n  }\n  if (casing === \"pascal\") {\n    return \"CreateDate\";\n  }\n  if (casing === \"kebab\") {\n    return \"create-date\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateBy(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\n    return options.renameMetaFields.created_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"createdby\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"createdBy\";\n  }\n  if (casing === \"snake\") {\n    return \"created_by\";\n  }\n  if (casing === \"pascal\") {\n    return \"CreatedBy\";\n  }\n  if (casing === \"kebab\") {\n    return \"created-by\";\n  }\n  return defautCase;\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log, recursivelyMapStorageUrls } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function GetOne<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetOneParams,\n  client: FireClient\n): Promise<ra.GetOneResult<T>> {\n  log(\"GetOne\", { resourceName, params });\n  const { rm, fireWrapper } = client;\n  try {\n    const id = params.id + \"\";\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\n    const data = await recursivelyMapStorageUrls(fireWrapper, dataSingle);\n    return { data: data };\n  } catch (error) {\n    throw new Error(\n      \"Error getting id: \" + params.id + \" from collection: \" + resourceName\n    );\n  }\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { filterArray, log, recursivelyMapStorageUrls, sortArray } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function GetList<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetListParams,\n  client: FireClient\n): Promise<ra.GetListResult<T>> {\n  log(\"GetList\", { resourceName, params });\n  const {\n    rm,\n    fireWrapper,\n    options\n  } = client;\n\n  const filterSafe = params.filter || {};\n\n  const collectionQuery = filterSafe.collectionQuery;\n  delete filterSafe.collectionQuery;\n\n  const r = await rm.TryGetResource(resourceName, \"REFRESH\", collectionQuery);\n  const data = r.list;\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === \"ASC\") {\n      sortArray(data, field, \"asc\");\n    } else {\n      sortArray(data, field, \"desc\");\n    }\n  }\n  let softDeleted = data;\n  if (options.softDelete && !Object.keys(filterSafe).includes(\"deleted\")) {\n    softDeleted = data.filter((doc) => !doc.deleted);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\n  const total = filteredData.length;\n\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data,\n      total,\n    };\n  }\n\n  return {\n    data: dataPage,\n    total,\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { filterArray, log, recursivelyMapStorageUrls, sortArray } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function GetManyReference<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyReferenceParams,\n  client: FireClient\n): Promise<ra.GetManyReferenceResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  log(\"GetManyReference\", { resourceName, params });\n  const filterSafe = params.filter || {};\n  const collectionQuery = filterSafe.collectionQuery;\n  const r = await rm.TryGetResource(\n    resourceName,\n    \"REFRESH\",\n    collectionQuery\n  );\n  delete filterSafe.collectionQuery;\n  log(\"apiGetManyReference\", { resourceName, resource: r, params });\n  const data = r.list;\n  const targetField = params.target;\n  const targetValue = params.id;\n  let softDeleted = data;\n  if (options.softDelete) {\n    softDeleted = data.filter(doc => !doc['deleted'])\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const targetIdFilter = {} as any;\n  targetIdFilter[targetField] = targetValue;\n  const permittedData = filterArray(filteredData, targetIdFilter);\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === \"ASC\") {\n      sortArray(permittedData, field, \"asc\");\n    } else {\n      sortArray(permittedData, field, \"desc\");\n    }\n  }\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\n  const total = permittedData.length;\n\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((doc) =>\n        recursivelyMapStorageUrls(fireWrapper, doc)\n      )\n    );\n    return { data, total };\n  }\n\n  return { data: dataPage, total };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log, recursivelyMapStorageUrls } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function GetMany<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyParams,\n  client: FireClient\n): Promise<ra.GetManyResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"GetMany\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const matchDocSnaps = await Promise.all(\n    ids.map((id) => r.collection.doc(id + \"\").get())\n  );\n  const matches = matchDocSnaps.map((snap) => {\n    return { ...snap.data(), id: snap.id } as T;\n  });\n  const permittedData = options.softDelete\n    ? matches.filter((row) => !row[\"deleted\"])\n    : matches;\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data,\n    };\n  }\n\n  return {\n    data: permittedData,\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function Create<T extends ra.Record>(\n  resourceName: string,\n  params: ra.CreateParams,\n  client: FireClient\n): Promise<ra.CreateResult<T>> {\n  const { rm, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"Create\", { resourceName, resource: r, params });\n  const hasOverridenDocId = params.data && params.data.id;\n  log(\"Create\", { hasOverridenDocId });\n  if (hasOverridenDocId) {\n    const overridenId = params.data.id;\n    const exists = (await r.collection.doc(overridenId).get()).exists;\n    if (exists) {\n      throw new Error(\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n      );\n    }\n    const data = await client.parseDataAndUpload(r, overridenId, params.data);\n    if (!overridenId) {\n      throw new Error(\"id must be a valid string\");\n    }\n    const docObj = { ...data };\n    client.checkRemoveIdField(docObj);\n    await client.addCreatedByFields(docObj);\n    await client.addUpdatedByFields(docObj);\n    log(\"Create\", { docObj });\n    await r.collection.doc(overridenId).set(docObj, { merge: false });\n    return {\n      data: {\n        ...data,\n        id: overridenId,\n      },\n    };\n  }\n  const newId = fireWrapper.db().collection(\"collections\").doc().id;\n  const data = await client.parseDataAndUpload(r, newId, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj);\n  await client.addCreatedByFields(docObj);\n  await client.addUpdatedByFields(docObj);\n  await r.collection.doc(newId).set(docObj, { merge: false });\n  return {\n    data: {\n      ...data,\n      id: newId,\n    },\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\nimport { DeleteSoft } from \"./Delete.Soft\";\n\nexport async function Delete<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm, options } = client;\n  if (options.softDelete) {\n    return DeleteSoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log(\"apiDelete\", { resourceName, resource: r, params });\n  try {\n    const id = params.id + \"\";\n    await r.collection.doc(id).delete();\n  } catch (error) {\n    throw new Error(error);\n  }\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log, logError } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function DeleteSoft<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm } = client;\n  const id = params.id + \"\";\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteSoft\", { resourceName, resource: r, params });\n  const docObj = { deleted: true };\n  await client.addUpdatedByFields(docObj);\n  r.collection\n    .doc(id)\n    .update(docObj)\n    .catch((error) => {\n      logError(\"DeleteSoft error\", { error });\n    });\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\nimport { DeleteManySoft } from \"./DeleteMany.Soft\";\n\ntype DocumentRef = firebase.firestore.DocumentReference<any>;\n\nexport async function DeleteMany(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { options, rm, fireWrapper } = client;\n  if (options.softDelete) {\n    return DeleteManySoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteMany\", { resourceName, resource: r, params });\n  const returnData: ra.Identifier[] = [];\n  const batch = fireWrapper.db().batch();\n  for (const id of params.ids) {\n    const idStr = id + '';\n    const docToDelete = r.collection.doc(idStr) as DocumentRef;\n    batch.delete(docToDelete);\n    returnData.push(id);\n  }\n  try {\n    await batch.commit();\n  } catch (error) {\n    throw new Error(error)\n  }\n  return { data: returnData };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log, logError } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function DeleteManySoft(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { rm, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteManySoft\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + \"\";\n      const docObj = { deleted: true };\n      await client.addUpdatedByFields(docObj);\n      r.collection\n        .doc(idStr)\n        .update(docObj)\n        .catch((error) => {\n          logError(\"apiSoftDeleteMany error\", { error });\n        });\n      return idStr;\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function Update<T extends ra.Record>(\n  resourceName: string,\n  params: ra.UpdateParams,\n  client: FireClient\n): Promise<ra.UpdateResult<T>> {\n  const { rm } = client;\n  log(\"Update\", { resourceName, params });\n  const id = params.id + \"\";\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"Update\", { resourceName, resource: r, params });\n  const data = await client.parseDataAndUpload(r, id, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj);\n  await client.addUpdatedByFields(docObj);\n  await r.collection.doc(id).update(docObj);\n  return {\n    data: {\n      ...data,\n      id: id,\n    },\n  };\n}\n","import { FireClient } from \"providers/database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function UpdateMany(\n  resourceName: string,\n  params: ra.UpdateManyParams,\n  client: FireClient\n): Promise<ra.UpdateManyResult> {\n  const { rm } = client;\n  log(\"UpdateMany\", { resourceName, params });\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"UpdateMany\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async id => {\n      const idStr = id+'';\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\n      const docObj = { ...data };\n      client.checkRemoveIdField(docObj);\n      await client.addUpdatedByFields(docObj);\n      await r.collection\n        .doc(idStr)\n        .update(docObj);\n      return {\n        ...data,\n        id: idStr\n      };\n    })\n  );\n  return {\n    data: returnData\n  };\n}\n","import { logError } from \"./../misc/logger\";\nimport {\n  getAbsolutePath,\n  log,\n  CheckLogging,\n  retrieveStatusCode,\n} from \"../misc\";\nimport * as ra from \"../misc/react-admin-models\";\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\nimport { FireApp } from \"./database/firebase/IFirebaseWrapper\";\nimport { FireClient } from \"./database/FireClient\";\nimport { GetList, GetMany, GetManyReference, GetOne } from \"./queries\";\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from \"./commands\";\n\nexport interface IDataProvider extends ra.DataProvider {\n  app: FireApp;\n}\n\nexport function DataProvider(\n  firebaseConfig: {},\n  optionsInput?: RAFirebaseOptions\n): IDataProvider {\n  const options = optionsInput || {};\n  VerifyDataProviderArgs(firebaseConfig, options);\n  CheckLogging(firebaseConfig, options);\n\n  log(\"react-admin-firebase:: Creating FirebaseDataProvider\", {\n    firebaseConfig,\n    options,\n  });\n\n  const fireWrapper = new FirebaseWrapper();\n  fireWrapper.init(firebaseConfig, optionsInput);\n\n  async function run<T>(cb: () => Promise<T>) {\n    let res: any;\n    try {\n      res = await cb();\n      return res;\n    } catch (error) {\n      const errorMsg = error.toString();\n      const code = retrieveStatusCode(errorMsg);\n      const errorObj = { status: code, message: errorMsg, json: res };\n      logError(\"DataProvider:\", error, { errorMsg, code, errorObj });\n      throw errorObj;\n    }\n  }\n  const client = new FireClient(fireWrapper, options);\n\n  const newProviderApi: IDataProvider = {\n    app: fireWrapper.GetApp(),\n    getList<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetListParams\n    ): Promise<ra.GetListResult<RecordType>> {\n      return run(() => GetList<RecordType>(resource, params, client));\n    },\n    getOne<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetOneParams\n    ): Promise<ra.GetOneResult<RecordType>> {\n      return run(() => GetOne<RecordType>(resource, params, client));\n    },\n    getMany<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyParams\n    ): Promise<ra.GetManyResult<RecordType>> {\n      return run(() => GetMany<RecordType>(resource, params, client));\n    },\n    getManyReference<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyReferenceParams\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\n      return run(() =>\n        GetManyReference<RecordType>(resource, params, client)\n      );\n    },\n    update<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.UpdateParams\n    ): Promise<ra.UpdateResult<RecordType>> {\n      return run(() => Update<RecordType>(resource, params, client));\n    },\n    updateMany(\n      resource: string,\n      params: ra.UpdateManyParams\n    ): Promise<ra.UpdateManyResult> {\n      return run(() => UpdateMany(resource, params, client));\n    },\n    create<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.CreateParams\n    ): Promise<ra.CreateResult<RecordType>> {\n      return run(() => Create<RecordType>(resource, params, client));\n    },\n    delete<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.DeleteParams\n    ): Promise<ra.DeleteResult<RecordType>> {\n      return run(() => Delete(resource, params, client));\n    },\n    deleteMany(\n      resource: string,\n      params: ra.DeleteManyParams\n    ): Promise<ra.DeleteManyResult> {\n      return run(() => DeleteMany(resource, params, client));\n    },\n  };\n\n  return newProviderApi;\n}\n\nfunction VerifyDataProviderArgs(\n  firebaseConfig: {},\n  options?: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\n    );\n  }\n  if (options && options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, \"test\");\n  }\n}\n","// From firebase SDK\n\nimport { logError } from \"./logger\";\n\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusTxt(status: number): \"ok\" | \"unauthenticated\" {\n  // Make sure any successful status is OK.\n  if (status >= 200 && status < 300) {\n    return \"ok\";\n  }\n  switch (status) {\n    case 401: // 'unauthenticated'\n    case 403: // 'permission-denied'\n      return \"unauthenticated\";\n\n    case 0: // 'internal'\n    case 400: // 'invalid-argument'\n    case 404: // 'not-found'\n    case 409: // 'aborted'\n    case 429: // 'resource-exhausted'\n    case 499: // 'cancelled'\n    case 500: // 'internal'\n    case 501: // 'unimplemented'\n    case 503: // 'unavailable'\n    case 504: // 'deadline-exceeded'\n    default:\n      // ignore\n      return \"ok\";\n  }\n}\n\n// From firebase SDK\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusCode(statusTxt: string): number {\n  // Make sure any successful status is OK.\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\n  const status = Array.isArray(regexResult) && regexResult[1];\n  if (!status) {\n    logError('unknown StatusCode ', {statusTxt});\n  }\n  switch (status) {\n    case 'unauthenticated':\n      return 401\n    case 'permission-denied':\n      return 403\n    case 'internal':\n      return 0\n    case 'invalid-argument':\n      return 400\n    case 'not-found':\n      return 404\n    case 'aborted':\n      return 409\n    case 'resource-exhausted':\n      return 429\n    case 'cancelled':\n      return 499\n    case 'internal':\n      return 500\n    case 'unimplemented':\n      return 501\n    case 'unavailable':\n      return 503\n    case 'deadline-exceeded':\n      return 504\n    default:\n      return 200;\n  }\n}\n","import { messageTypes } from \"./../misc/messageTypes\";\nimport firebase from \"firebase/app\";\nimport \"firebase/auth\";\nimport { FirebaseAuth, User } from \"@firebase/auth-types\";\nimport { log, CheckLogging, retrieveStatusTxt, logWarn } from \"../misc\";\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\nimport {\n  AuthProvider as RaAuthProvider,\n  UserIdentity,\n} from \"../misc/react-admin-models\";\n\nclass AuthClient {\n  private auth: FirebaseAuth;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log(\"Auth Client: initializing...\", { firebaseConfig, options });\n    const fireWrapper = new FirebaseWrapper();\n    fireWrapper.init(firebaseConfig, options);\n    this.auth = fireWrapper.auth();\n    options.persistence && this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: \"session\" | \"local\" | \"none\") {\n    let persistenceResolved: string;\n    switch (persistenceInput) {\n      case \"local\":\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\n        break;\n      case \"none\":\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\n        break;\n      case \"session\":\n      default:\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\n        break;\n    }\n    log(\"setPersistence\", { persistenceInput, persistenceResolved });\n    this.auth\n      .setPersistence(persistenceResolved)\n      .catch((error) => console.error(error));\n  }\n\n  public async HandleAuthLogin(params: { username: string; password: string }) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.auth.signInWithEmailAndPassword(\n          username,\n          password\n        );\n        log(\"HandleAuthLogin: user sucessfully logged in\", { user });\n        return user;\n      } catch (e) {\n        log(\"HandleAuthLogin: invalid credentials\", { params });\n        throw new Error(\"Login error: invalid credentials\");\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.auth.signOut();\n  }\n\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\n    log(\"HandleAuthLogin: invalid credentials\", { errorHttp });\n    const status = !!errorHttp && errorHttp.status;\n    const statusTxt = retrieveStatusTxt(status);\n    if (statusTxt === \"ok\") {\n      log(\"API is actually authenticated\");\n      return Promise.resolve();\n    }\n    logWarn(\"Recieved authentication error from API\");\n    return Promise.reject();\n  }\n\n  public async HandleAuthCheck(): Promise<void> {\n    return this.getUserLogin() as any; // Prevents breaking change\n  }\n\n  public getUserLogin(): Promise<User> {\n    return new Promise((resolve, reject) => {\n      if (this.auth.currentUser) return resolve(this.auth.currentUser);\n      const unsubscribe = this.auth.onAuthStateChanged((user) => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log(\"HandleGetPermission: no user is logged in or tokenResult error\", {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetIdentity(): Promise<UserIdentity> {\n    try {\n      const { uid, displayName, photoURL } = await this.getUserLogin();\n      const identity: UserIdentity = {\n        id: uid,\n        fullName: displayName+'',\n        avatar: photoURL+'',\n      };\n      return identity;\n    } catch (e) {\n      log(\"HandleGetIdentity: no user is logged in\", {\n        e,\n      });\n      return null as any;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log(\"HandleGetJWTAuthTime: no user is logged in or tokenResult error\", {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\n        \"HandleGetJWTExpirationTime: no user is logged in or tokenResult error\",\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\n        \"HandleGetJWTSignInProvider: no user is logged in or tokenResult error\",\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\n        \"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\",\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log(\n        \"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\",\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): RaAuthProvider {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  const auth = new AuthClient(firebaseConfig, options);\n  CheckLogging(firebaseConfig, options);\n\n  const provider: RaAuthProvider = {\n    // React Admin Interface\n    login: (params) => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: (error) => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getIdentity: () => auth.HandleGetIdentity(),\n    // Custom Functions\n    getAuthUser: () => auth.getUserLogin(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken(),\n  };\n  return provider;\n}\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\n    );\n  }\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_forTo","array","body","check","reject","i","_cycle","length","thenable","_catch","recover","Symbol","iterator","asyncIterator","SimpleLogger","constructor","isEnabled","localStorage","getItem","log","console","title","warn","error","const","logger","CheckLogging","config","options","debug","logging","setItem","removeItem","logWarn","logError","sortArray","data","field","dir","sort","a","b","rawA","get","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","searchField","searchValue","tree","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","objectFlatten","getFieldReferences","filter","row","reduce","acc","cur","searchThis","toString","includes","doesRowMatch","recursivelyMapStorageUrls","fireWrapper","fieldValue","isArray","isObject","storage","ref","src","getDownloadURL","target","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","slice","joinPaths","args","FirebaseWrapper","GetApp","app","init","firebaseConfig","optionsSafe","firebase","apps","initializeApp","ObtainFirebaseApp","firestore","db","serverTimestamp","auth","GetUserLogin","Promise","resolve","onAuthStateChanged","user","OnUserLogout","callBack","isLoggedOut","ResourceManager","resources","TryGetResource","resourceName","refresh","collectionQuery","TryGetResourcePromise","RefreshResource","GetResource","resource","_this2","initPath","_this3","collection","query","applyQuery","newDocs","list","docs","doc","parseFireStoreDocument","collectionPath","GetSingleDoc","docId","_this4","docSnap","exists","absolutePath","hasBeenInited","pathAbsolute","allResources","recusivelyCheckObjectValue","input","toDate","id","getUserIdentifier","associateUsersById","getCurrentUserId","getCurrentUserEmail","email","uid","removeResource","collref","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","parseDataAndUpload","r","docPath","uploads","recusivelyParseObjectValue","fieldPath","index","fieldDotsPath","fieldSlashesPath","rawFile","parseDocGetAllUploads","all","u","uploadAndGetLink","useFileNamesInStorage","link","set","addCreatedByFields","disableMeta","currentUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","addUpdatedByFields","updateAtSelector","updated_at","GetSelectorsUpdateAt","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","useFileName","storagePath","name","saveFile","task","_this5","put","res","rej","catch","taskResult","relativeFilePaths","storageError","code","GetOne","params","client","dataSingle","GetList","filterSafe","dataPage","total","softDeleted","softDelete","deleted","filteredData","pageStart","pagination","page","perPage","GetManyReference","targetField","targetValue","targetIdFilter","permittedData","GetMany","ids","matchDocSnaps","matches","snap","Create","newId","docObj","merge","hasOverridenDocId","overridenId","_r$collection$doc$get","Delete","update","previousData","DeleteSoft","delete","DeleteMany","idStr","returnData","DeleteManySoft","batch","docToDelete","commit","Update","UpdateMany","DataProvider","optionsInput","run","cb","errorMsg","statusTxt","regexResult","exec","status","retrieveStatusCode","errorObj","message","json","VerifyDataProviderArgs","getList","getOne","getMany","getManyReference","updateMany","create","deleteMany","AuthClient","persistence","setPersistence","AuthProvider","VerifyAuthProviderArgs","login","HandleAuthLogin","logout","HandleAuthLogout","checkAuth","HandleAuthCheck","checkError","HandleAuthError","getPermissions","HandleGetPermissions","getIdentity","HandleGetIdentity","getAuthUser","getUserLogin","getJWTAuthTime","HandleGetJWTAuthTime","getJWTExpirationTime","HandleGetJWTExpirationTime","getJWTSignInProvider","HandleGetJWTSignInProvider","getJWTClaims","getJWTToken","HandleGetJWTToken","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","username","password","signInWithEmailAndPassword","signOut","errorHttp","retrieveStatusTxt","currentUser","unsubscribe","getIdTokenResult","token","claims","fullName","avatar","authTime","_this6","expirationTime","_this7","signInProvider","HandleGetJWTIssuedAtTime","_this8","issuedAtTime","_this9"],"mappings":"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"}